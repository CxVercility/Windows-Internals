
\documentclass[10pt,twocolumn,a4paper]{article}
\usepackage{styles/usenix-style}

\author{Fabian Nguyen}


\usepackage{cite,xspace,ifthen,graphicx,listings}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[
   pdfauthor={Fabian Nguyen},
   pdftitle={Advanced Exploit Mitigation},
   pdfsubject={Windows Internals},
   pdfkeywords={Security,Stack Overflow,Return Oriented Programming, Control Flow Guard, Shadow Stack}
]{hyperref}
\usepackage[nonumberlist, section]{glossaries}
\usepackage{hyperref}

\begin{document}

\title{Windows Internals: Advanced Exploit Mitigation}

\newcommand{\todo}[1]{{\texttt{[#1]}}}
\newcommand{\code}[1]{{\tt \small{#1}}}

\maketitle


\begin{abstract}
We take a look at general techniques used by attackers to compromise Windows systems and some fundamental defense mechanisms against them.
This paper will provide an overview of Microsoft's latest additions to the security concept of the Windows Operating System [OS] , analyse inherent flaws in their design and take a brief look at already existing attacks. 
\end{abstract}

\section{Introduction}\label{sec:introduction}
In an increasingly digitalized world an overwhelming amount of private and/or safety-critical information and data is stored on computers.
Windows is by far the most used operating system and therefore the main target of attackers to compromise data or computer systems.
One common intent of attackers is to steal an individual's passcode, e.g for an online-banking website.
Naturally, as the amount and complexity of attacks rises, OS vendors are forced to put an increasingly high amount of effort into mitigating existing weaknesses and deny attackers of further possibilities to compromise their OS.
Even though this is the case, the amount of potentially abusable vulnerabilities in Windows has been increasing, instead of decreasing.
\cite{CVE}

\begin{figure}[htbp]
\includegraphics[width=8cm, height=2.5cm]{fig/stats}
\caption{Amount of documented vulnerabilities in the Windows Operating System.\newline Note that the spike in "Gain Information" vulnerabilities in 2017 is inflated by a family of attacks widely known as Meltdown/Spectre}
\end{figure}

We can see that the three largest groups of vulnerabilities consist of "Gain Information", "Code Execution" and "Overflow".
Of course these three categories aren't entirely separated from each other.
An attacker that is able to execute code on a machine often does so in order to gain information and overflows are often the reason why an attacker can execute code in the first place.
\section{Overflows}\label{sec:Overflows}
An overflow happens when a program writes data to memory beyond the limits of the intended data structure.
One common example of this is a stack buffer overflow caused by an incorrect use of the function \emph{strcpy}\footnote{"char * strcpy ( char * destination, const char * source )" is a C function that copies a string into the specified memory}.
More precisely, an overflow can occur when the given input is longer than the buffer one writes too.
%%\includegraphics{fig/simpleoverflow}
%%\caption{The password's length is too large to fit into the designated buffer.However, strcpy will not check for valid sizes so it will continuously write beyond the buffer.}
Relatively small-in-size overflows are not always easy to spot and often remain unidentified if they don't cause immediate errors.
Besides causing faulty program behaviour, this also provides a critical attack surface.
To see why this is the case, let's take a look at a typical stack layout with only one buffer present right at the beginning.
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[height=7cm,width=6cm]{fig/Stack_Overflow}
		\caption{A typical stack layout}
	\end{center}
\end{figure}
\newline
As we can see, the stack will usually contain a return address right at the bottom, a frame pointer on top of it and then local data that is used by the current function.
Obviously, one will also need to keep the parent function's data saved below (stack grows upwards).
In our example there is only one character buffer of size 12 and a pointer to it present.
Suppose one wants to copy user-input string into this buffer, e.g by using \emph{strcpy}.
The user may now unknowingly or perhaps purposely overflow this buffer by entering a string that's longer than 12 characters.
As we observed earlier, this will result in a memory-write beyond the buffer's bounds. 
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[height=7cm,width=8cm]{fig/Stack_Overflow2}
		\caption{The user-input is too long for the given buffer}
	\end{center}
\end{figure}
\newline 
In this example we can see that our pointer to the buffer is overwritten, as well as the stack frame we had saved on the stack earlier.
Most importantly though, the return address is also corrupted.
In the given figure, the input is constructed so that the part that's written over the return address resembles an address itself.
In this case, its just the address of the buffer again.
At some point, our given function will attempt to return to this address.
However, once it does so, all it will be able to read from this address is a swarm of  'A's which certainly doesn't resemble a valid sequence of code.
The program will fault and terminate.
This problem has existed for as long as the concept of the stack itself so naturally techniques to (try) prevent this from happening were implemented long ago.

\section{Data Execution Prevention}\label{sec:DEP}
One easy, and naive way to address the aforementioned issue is the use of Data Execution Prevention (DEP).
DEP follows a very simple approach to prevent the execution of code from malicious addresses.
Note that an attacker that uses overflows can usually only manipulate the stack which is typically used for non-executable data only (this is also true for heap overflows).
Since we know that, we could easily mark the entire memory-area\footnote{Sometimes code needs to be run directly from the stack, e.g just-in-time compiled JavaScript code, so this is a very simplified approach} (with an additional attribute for memory pages) that is used as a stack as \emph{non-executable} or "NX" in short and that is basically what DEP does.
Whenever an attempt to run code is made a check will ensure that the "NX"-Bit for the according page is not set.If it is, the program will terminate immediately.
This approach offers an easy solution to prevent the \emph{generation} of executable code on the stack. However, it does \emph{not} prevent an attacker from redirecting control flow to already existing code. Attacks that abused this flaw could therefore still compromise or even take over a program.\footnote{A well known way to do this is a \hyperref{https://en.wikipedia.org/wiki/Return-to-libc_attack}{Return-to-Libc Exploits}{name}{return-to-libc attack}}

\section{Address Space Layout Randomization}\label{sec:ASLR}
Address Space Layout Randomization (ASLR) was implemented to address this issue.
Since an attacker that uses pre-existing code needs to be able to tell where the code he wants to use is, an easy solution is to prevent them from addressing said code.
ASLR does this by randomizing the arrangement of segments like the stack, heap and DLLs in memory.\footnote{32 bit Windows randomizes 8 of the address' bits, 64 Bit Windows can randomize a total of 19 bits.}

\section{Return Oriented Programming}\label{ROP}
Return oriented programming describes one of the most popular approaches to manipulating programs by hijacking control-flow through the manipulation of return addresses.
In essence, there are 3 steps to do :
\begin{enumerate}
	\item Finding a security vulnerability that allows one to manipulate memory
	\item Writing code (also called Payload or Shellcode\footnote{The name Shellcode comes from the fact that such attacks often inject code to open a Shell on the target system} on the stack 
	\item Manipulating the return address to point to the injected code
\end{enumerate}
Windows did not offer any kind of protection against ROP attacks until 2004 when DEP was introduced.
However, as already mentioned, attackers quickly overcame this barrier by using already existent code which would not be marked non-executable.
One proposed "solution" to this was to store the first argument of each function in a register instead. Registers are not as easy to manipulate due to not being explicitly writeable in theory, though attackers easily overcame this restriction as well.
Instead of using complete functions they would now use only small portions of a function that ended in a return instruction. Obviously, instruction sequences that allowed to manipulate registers were especially useful, in order to invoke complete functions again.
However, this is not needed as the usage of such so called "gadgets" is already turing-complete given a \emph{big enough}\cite{gadgets} program.
This is made even easier by the fact that one can use instruction sequences that weren't supposed to be in the program to begin with.
To see how this is possible, recall how machine code is written and read by the CPU.
Note that in contrast to natural language, machine code doesn't include any white space (e.g spaces or slashes) so one may start reading wherever they want.
The following figure shows an example where 2 instructions are split into 4 just by removing 1 Byte at the start.
\begin{figure}[htbp]
  \includegraphics[keepaspectratio,width=8cm]{fig/ByteCode}
  \caption{An example of an unintended use of machine code \cite{geometry}}
\end{figure}
 %\begin{figure}[htbp]
%  \centering
%  \fbox{\parbox{.8\columnwidth}{
%      Here you can include a sample figure.  Use something like
%      \begin{center}
%        \code{$\backslash$includegraphics[scale=.8]\{template\}}
%      \end{center}
%      to include an encapsulated postscript figure.  The \emph{scale}
%      argument can be used for scaling the picture, although it
%      may scale the font incorrectly.
%    }}
%  \caption{Sample Figure}
%  \label{fig:sample}
%\end{figure}


%\lstset{language=C, basicstyle=\ttfamily,
%        string=[b]', showspaces=false, showtabs=false,
%        caption={A sample code snippet}, captionpos=b}
%\begin{lstlisting}
%/* code snippet  */
%while (!sleep)
%	sleep++;
%\end{lstlisting}

%\begin{figure}[hbt]
%\centering
%\includegraphics[scale=.7,clip]{fig/OIUKAvV}
%\caption{Sample figure automatically from Windows prn.\label{plot:fig}}
%\end{figure}
 

\section{Approach}

\section{Conclusion}\label{sec:conclusion}



\bibliographystyle{ieeetr}
\bibliography{Advanced Exploit Mitigation}
%\footnotesize
\end{document}

}